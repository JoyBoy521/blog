---
isOriginal: true
date: 2024-10-29
---

# 网鼎杯青龙组初赛

### 赛题名称：REVERSE02

<!-- more -->

![1](/ctf/2024网鼎杯/image001.png)

前半部分，很容易看明白。写代码可以解出来flag一 二部分。

```c
#include <iostream>
int main() {
  char flag[32];  // 定义为字符数组
  int a[] = {96, 98, 110, 96, 196, 102, 114, 198};  // 整数数组
  // 将 a[i] 除以 2 的结果存入 flag
  for (int i = 0; i < 8; i++) {
	 flag[i] = a[i] / 2;  
  }
	// 定义数组 b 和字符串 v22
  int b[] = {109, 10, 22, 64, 120, 12, 68, 87}; // 整数数组
  const char* v22 = "XorrLord";  // 字符串
  // 使用异或操作填充 flag 的剩余部分
  for (int j = 8; j < 16; ++j) { // 注意这里的条件是 j < 16
	flag[j] = b[j - 8] ^ v22[j - 8]; // 将 b 和 v22 进行异或
  }
  // 输出 flag 数组中的字符
  for (int i = 0; i < 16; i++) {  // 输出 flag 的前 16 个字符
	std::cout << flag[i];  // 输出每个字符
  }
  std::cout << std::endl; // 输出换行
  return 0;
}
```

第三部分的base64也可以解出来。

码表换一下就可以了。

![2](/ctf/2024网鼎杯/image003.png)

![3](/ctf/2024网鼎杯/image005.png)

 

最后的aes

下好断点。

 

![4](/ctf/2024网鼎杯/image007.png)

![5](/ctf/2024网鼎杯/image009.png)

随便输入32位进去，过检测。

 

![6](/ctf/2024网鼎杯/image011.png)

 

修改RIP地址跳过中间那一段，直接去分析aes。

![7](/ctf/2024网鼎杯/image013.png)

v8看逻辑像是vi,我们绕过来就是为了看v8和密钥到底是什么。在外面看v8不是很舒服，双击进去。

![8](/ctf/2024网鼎杯/image015.png)

发现是8个0，8个8

![9](/ctf/2024网鼎杯/image017.png)

![10](/ctf/2024网鼎杯/image019.png)

密钥就是AesMasterAesMast

咱也去cyberchef解，mode咱们不知道，就一个一个换。

到ECB的时候就好了。

![11](/ctf/2024网鼎杯/image021.png)

把四个拼接到一起就是flag。

:::tip 提示

远程linux动调的时候，会出现缺libssl.so.10的报错。

[找不到libssl.so.10的终极解决方案 - Ubuntu 18 - HENCH@T](https://henchat.net/找不到libssl-so-10的终极解决方案-ubuntu-18/)

我是看这篇文章补上的。

:::

